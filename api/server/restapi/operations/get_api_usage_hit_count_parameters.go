// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NewGetAPIUsageHitCountParams creates a new GetAPIUsageHitCountParams object
//
// There are no default values defined in the spec.
func NewGetAPIUsageHitCountParams() GetAPIUsageHitCountParams {

	return GetAPIUsageHitCountParams{}
}

// GetAPIUsageHitCountParams contains all the bound params for the get API usage hit count operation
// typically these are obtained from a http.Request
//
// swagger:parameters GetAPIUsageHitCount
type GetAPIUsageHitCountParams struct {

	// HTTP Request Object
	HTTPRequest *http.Request `json:"-"`

	/*
	  In: query
	*/
	DestinationIPIsNot []string
	/*
	  In: query
	*/
	DestinationIPIs []string
	/*
	  In: query
	*/
	DestinationPortIsNot []string
	/*
	  In: query
	*/
	DestinationPortIs []string
	/*End time of the query
	  Required: true
	  In: query
	*/
	EndTime strfmt.DateTime
	/*
	  In: query
	*/
	HasSpecDiffIs *bool
	/*
	  In: query
	*/
	MethodIs []string
	/*
	  In: query
	*/
	PathContains []string
	/*
	  In: query
	*/
	PathEnd *string
	/*
	  In: query
	*/
	PathIsNot []string
	/*
	  In: query
	*/
	PathIs []string
	/*
	  In: query
	*/
	PathStart *string
	/*
	  In: query
	*/
	ProvidedPathIDIs []string
	/*
	  In: query
	*/
	ReconstructedPathIDIs []string
	/*
	  Required: true
	  In: query
	*/
	ShowNonAPI bool
	/*
	  In: query
	*/
	SourceIPIsNot []string
	/*
	  In: query
	*/
	SourceIPIs []string
	/*
	  In: query
	*/
	SpecDiffTypeIs []string
	/*
	  In: query
	*/
	SpecContains []string
	/*
	  In: query
	*/
	SpecEnd *string
	/*
	  In: query
	*/
	SpecIsNot []string
	/*
	  In: query
	*/
	SpecIs []string
	/*
	  In: query
	*/
	SpecStart *string
	/*Start time of the query
	  Required: true
	  In: query
	*/
	StartTime strfmt.DateTime
	/*greater than or equal
	  In: query
	*/
	StatusCodeGte *string
	/*
	  In: query
	*/
	StatusCodeIsNot []string
	/*
	  In: query
	*/
	StatusCodeIs []string
	/*less than or equal
	  In: query
	*/
	StatusCodeLte *string
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls.
//
// To ensure default values, the struct must have been initialized with NewGetAPIUsageHitCountParams() beforehand.
func (o *GetAPIUsageHitCountParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error

	o.HTTPRequest = r

	qs := runtime.Values(r.URL.Query())

	qDestinationIPIsNot, qhkDestinationIPIsNot, _ := qs.GetOK("destinationIP[isNot]")
	if err := o.bindDestinationIPIsNot(qDestinationIPIsNot, qhkDestinationIPIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qDestinationIPIs, qhkDestinationIPIs, _ := qs.GetOK("destinationIP[is]")
	if err := o.bindDestinationIPIs(qDestinationIPIs, qhkDestinationIPIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qDestinationPortIsNot, qhkDestinationPortIsNot, _ := qs.GetOK("destinationPort[isNot]")
	if err := o.bindDestinationPortIsNot(qDestinationPortIsNot, qhkDestinationPortIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qDestinationPortIs, qhkDestinationPortIs, _ := qs.GetOK("destinationPort[is]")
	if err := o.bindDestinationPortIs(qDestinationPortIs, qhkDestinationPortIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qEndTime, qhkEndTime, _ := qs.GetOK("endTime")
	if err := o.bindEndTime(qEndTime, qhkEndTime, route.Formats); err != nil {
		res = append(res, err)
	}

	qHasSpecDiffIs, qhkHasSpecDiffIs, _ := qs.GetOK("hasSpecDiff[is]")
	if err := o.bindHasSpecDiffIs(qHasSpecDiffIs, qhkHasSpecDiffIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qMethodIs, qhkMethodIs, _ := qs.GetOK("method[is]")
	if err := o.bindMethodIs(qMethodIs, qhkMethodIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qPathContains, qhkPathContains, _ := qs.GetOK("path[contains]")
	if err := o.bindPathContains(qPathContains, qhkPathContains, route.Formats); err != nil {
		res = append(res, err)
	}

	qPathEnd, qhkPathEnd, _ := qs.GetOK("path[end]")
	if err := o.bindPathEnd(qPathEnd, qhkPathEnd, route.Formats); err != nil {
		res = append(res, err)
	}

	qPathIsNot, qhkPathIsNot, _ := qs.GetOK("path[isNot]")
	if err := o.bindPathIsNot(qPathIsNot, qhkPathIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qPathIs, qhkPathIs, _ := qs.GetOK("path[is]")
	if err := o.bindPathIs(qPathIs, qhkPathIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qPathStart, qhkPathStart, _ := qs.GetOK("path[start]")
	if err := o.bindPathStart(qPathStart, qhkPathStart, route.Formats); err != nil {
		res = append(res, err)
	}

	qProvidedPathIDIs, qhkProvidedPathIDIs, _ := qs.GetOK("providedPathID[is]")
	if err := o.bindProvidedPathIDIs(qProvidedPathIDIs, qhkProvidedPathIDIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qReconstructedPathIDIs, qhkReconstructedPathIDIs, _ := qs.GetOK("reconstructedPathID[is]")
	if err := o.bindReconstructedPathIDIs(qReconstructedPathIDIs, qhkReconstructedPathIDIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qShowNonAPI, qhkShowNonAPI, _ := qs.GetOK("showNonApi")
	if err := o.bindShowNonAPI(qShowNonAPI, qhkShowNonAPI, route.Formats); err != nil {
		res = append(res, err)
	}

	qSourceIPIsNot, qhkSourceIPIsNot, _ := qs.GetOK("sourceIP[isNot]")
	if err := o.bindSourceIPIsNot(qSourceIPIsNot, qhkSourceIPIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qSourceIPIs, qhkSourceIPIs, _ := qs.GetOK("sourceIP[is]")
	if err := o.bindSourceIPIs(qSourceIPIs, qhkSourceIPIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qSpecDiffTypeIs, qhkSpecDiffTypeIs, _ := qs.GetOK("specDiffType[is]")
	if err := o.bindSpecDiffTypeIs(qSpecDiffTypeIs, qhkSpecDiffTypeIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qSpecContains, qhkSpecContains, _ := qs.GetOK("spec[contains]")
	if err := o.bindSpecContains(qSpecContains, qhkSpecContains, route.Formats); err != nil {
		res = append(res, err)
	}

	qSpecEnd, qhkSpecEnd, _ := qs.GetOK("spec[end]")
	if err := o.bindSpecEnd(qSpecEnd, qhkSpecEnd, route.Formats); err != nil {
		res = append(res, err)
	}

	qSpecIsNot, qhkSpecIsNot, _ := qs.GetOK("spec[isNot]")
	if err := o.bindSpecIsNot(qSpecIsNot, qhkSpecIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qSpecIs, qhkSpecIs, _ := qs.GetOK("spec[is]")
	if err := o.bindSpecIs(qSpecIs, qhkSpecIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qSpecStart, qhkSpecStart, _ := qs.GetOK("spec[start]")
	if err := o.bindSpecStart(qSpecStart, qhkSpecStart, route.Formats); err != nil {
		res = append(res, err)
	}

	qStartTime, qhkStartTime, _ := qs.GetOK("startTime")
	if err := o.bindStartTime(qStartTime, qhkStartTime, route.Formats); err != nil {
		res = append(res, err)
	}

	qStatusCodeGte, qhkStatusCodeGte, _ := qs.GetOK("statusCode[gte]")
	if err := o.bindStatusCodeGte(qStatusCodeGte, qhkStatusCodeGte, route.Formats); err != nil {
		res = append(res, err)
	}

	qStatusCodeIsNot, qhkStatusCodeIsNot, _ := qs.GetOK("statusCode[isNot]")
	if err := o.bindStatusCodeIsNot(qStatusCodeIsNot, qhkStatusCodeIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qStatusCodeIs, qhkStatusCodeIs, _ := qs.GetOK("statusCode[is]")
	if err := o.bindStatusCodeIs(qStatusCodeIs, qhkStatusCodeIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qStatusCodeLte, qhkStatusCodeLte, _ := qs.GetOK("statusCode[lte]")
	if err := o.bindStatusCodeLte(qStatusCodeLte, qhkStatusCodeLte, route.Formats); err != nil {
		res = append(res, err)
	}
	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// bindDestinationIPIsNot binds and validates array parameter DestinationIPIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindDestinationIPIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvDestinationIPIsNot string
	if len(rawData) > 0 {
		qvDestinationIPIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	destinationIPIsNotIC := swag.SplitByFormat(qvDestinationIPIsNot, "")
	if len(destinationIPIsNotIC) == 0 {
		return nil
	}

	var destinationIPIsNotIR []string
	for _, destinationIPIsNotIV := range destinationIPIsNotIC {
		destinationIPIsNotI := destinationIPIsNotIV

		destinationIPIsNotIR = append(destinationIPIsNotIR, destinationIPIsNotI)
	}

	o.DestinationIPIsNot = destinationIPIsNotIR

	return nil
}

// bindDestinationIPIs binds and validates array parameter DestinationIPIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindDestinationIPIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvDestinationIPIs string
	if len(rawData) > 0 {
		qvDestinationIPIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	destinationIPIsIC := swag.SplitByFormat(qvDestinationIPIs, "")
	if len(destinationIPIsIC) == 0 {
		return nil
	}

	var destinationIPIsIR []string
	for _, destinationIPIsIV := range destinationIPIsIC {
		destinationIPIsI := destinationIPIsIV

		destinationIPIsIR = append(destinationIPIsIR, destinationIPIsI)
	}

	o.DestinationIPIs = destinationIPIsIR

	return nil
}

// bindDestinationPortIsNot binds and validates array parameter DestinationPortIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindDestinationPortIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvDestinationPortIsNot string
	if len(rawData) > 0 {
		qvDestinationPortIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	destinationPortIsNotIC := swag.SplitByFormat(qvDestinationPortIsNot, "")
	if len(destinationPortIsNotIC) == 0 {
		return nil
	}

	var destinationPortIsNotIR []string
	for _, destinationPortIsNotIV := range destinationPortIsNotIC {
		destinationPortIsNotI := destinationPortIsNotIV

		destinationPortIsNotIR = append(destinationPortIsNotIR, destinationPortIsNotI)
	}

	o.DestinationPortIsNot = destinationPortIsNotIR

	return nil
}

// bindDestinationPortIs binds and validates array parameter DestinationPortIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindDestinationPortIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvDestinationPortIs string
	if len(rawData) > 0 {
		qvDestinationPortIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	destinationPortIsIC := swag.SplitByFormat(qvDestinationPortIs, "")
	if len(destinationPortIsIC) == 0 {
		return nil
	}

	var destinationPortIsIR []string
	for _, destinationPortIsIV := range destinationPortIsIC {
		destinationPortIsI := destinationPortIsIV

		destinationPortIsIR = append(destinationPortIsIR, destinationPortIsI)
	}

	o.DestinationPortIs = destinationPortIsIR

	return nil
}

// bindEndTime binds and validates parameter EndTime from query.
func (o *GetAPIUsageHitCountParams) bindEndTime(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("endTime", "query", rawData)
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// AllowEmptyValue: false

	if err := validate.RequiredString("endTime", "query", raw); err != nil {
		return err
	}

	// Format: date-time
	value, err := formats.Parse("date-time", raw)
	if err != nil {
		return errors.InvalidType("endTime", "query", "strfmt.DateTime", raw)
	}
	o.EndTime = *(value.(*strfmt.DateTime))

	if err := o.validateEndTime(formats); err != nil {
		return err
	}

	return nil
}

// validateEndTime carries on validations for parameter EndTime
func (o *GetAPIUsageHitCountParams) validateEndTime(formats strfmt.Registry) error {

	if err := validate.FormatOf("endTime", "query", "date-time", o.EndTime.String(), formats); err != nil {
		return err
	}
	return nil
}

// bindHasSpecDiffIs binds and validates parameter HasSpecDiffIs from query.
func (o *GetAPIUsageHitCountParams) bindHasSpecDiffIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("hasSpecDiff[is]", "query", "bool", raw)
	}
	o.HasSpecDiffIs = &value

	return nil
}

// bindMethodIs binds and validates array parameter MethodIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindMethodIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvMethodIs string
	if len(rawData) > 0 {
		qvMethodIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	methodIsIC := swag.SplitByFormat(qvMethodIs, "")
	if len(methodIsIC) == 0 {
		return nil
	}

	var methodIsIR []string
	for i, methodIsIV := range methodIsIC {
		methodIsI := methodIsIV

		if err := validate.EnumCase(fmt.Sprintf("%s.%v", "method[is]", i), "query", methodIsI, []interface{}{"GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH"}, true); err != nil {
			return err
		}

		methodIsIR = append(methodIsIR, methodIsI)
	}

	o.MethodIs = methodIsIR

	return nil
}

// bindPathContains binds and validates array parameter PathContains from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindPathContains(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvPathContains string
	if len(rawData) > 0 {
		qvPathContains = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	pathContainsIC := swag.SplitByFormat(qvPathContains, "")
	if len(pathContainsIC) == 0 {
		return nil
	}

	var pathContainsIR []string
	for _, pathContainsIV := range pathContainsIC {
		pathContainsI := pathContainsIV

		pathContainsIR = append(pathContainsIR, pathContainsI)
	}

	o.PathContains = pathContainsIR

	return nil
}

// bindPathEnd binds and validates parameter PathEnd from query.
func (o *GetAPIUsageHitCountParams) bindPathEnd(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.PathEnd = &raw

	return nil
}

// bindPathIsNot binds and validates array parameter PathIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindPathIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvPathIsNot string
	if len(rawData) > 0 {
		qvPathIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	pathIsNotIC := swag.SplitByFormat(qvPathIsNot, "")
	if len(pathIsNotIC) == 0 {
		return nil
	}

	var pathIsNotIR []string
	for _, pathIsNotIV := range pathIsNotIC {
		pathIsNotI := pathIsNotIV

		pathIsNotIR = append(pathIsNotIR, pathIsNotI)
	}

	o.PathIsNot = pathIsNotIR

	return nil
}

// bindPathIs binds and validates array parameter PathIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindPathIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvPathIs string
	if len(rawData) > 0 {
		qvPathIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	pathIsIC := swag.SplitByFormat(qvPathIs, "")
	if len(pathIsIC) == 0 {
		return nil
	}

	var pathIsIR []string
	for _, pathIsIV := range pathIsIC {
		pathIsI := pathIsIV

		pathIsIR = append(pathIsIR, pathIsI)
	}

	o.PathIs = pathIsIR

	return nil
}

// bindPathStart binds and validates parameter PathStart from query.
func (o *GetAPIUsageHitCountParams) bindPathStart(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.PathStart = &raw

	return nil
}

// bindProvidedPathIDIs binds and validates array parameter ProvidedPathIDIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindProvidedPathIDIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvProvidedPathIDIs string
	if len(rawData) > 0 {
		qvProvidedPathIDIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	providedPathIDIsIC := swag.SplitByFormat(qvProvidedPathIDIs, "")
	if len(providedPathIDIsIC) == 0 {
		return nil
	}

	var providedPathIDIsIR []string
	for _, providedPathIDIsIV := range providedPathIDIsIC {
		providedPathIDIsI := providedPathIDIsIV

		providedPathIDIsIR = append(providedPathIDIsIR, providedPathIDIsI)
	}

	o.ProvidedPathIDIs = providedPathIDIsIR

	return nil
}

// bindReconstructedPathIDIs binds and validates array parameter ReconstructedPathIDIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindReconstructedPathIDIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvReconstructedPathIDIs string
	if len(rawData) > 0 {
		qvReconstructedPathIDIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	reconstructedPathIDIsIC := swag.SplitByFormat(qvReconstructedPathIDIs, "")
	if len(reconstructedPathIDIsIC) == 0 {
		return nil
	}

	var reconstructedPathIDIsIR []string
	for _, reconstructedPathIDIsIV := range reconstructedPathIDIsIC {
		reconstructedPathIDIsI := reconstructedPathIDIsIV

		reconstructedPathIDIsIR = append(reconstructedPathIDIsIR, reconstructedPathIDIsI)
	}

	o.ReconstructedPathIDIs = reconstructedPathIDIsIR

	return nil
}

// bindShowNonAPI binds and validates parameter ShowNonAPI from query.
func (o *GetAPIUsageHitCountParams) bindShowNonAPI(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("showNonApi", "query", rawData)
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// AllowEmptyValue: false

	if err := validate.RequiredString("showNonApi", "query", raw); err != nil {
		return err
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("showNonApi", "query", "bool", raw)
	}
	o.ShowNonAPI = value

	return nil
}

// bindSourceIPIsNot binds and validates array parameter SourceIPIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindSourceIPIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvSourceIPIsNot string
	if len(rawData) > 0 {
		qvSourceIPIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	sourceIPIsNotIC := swag.SplitByFormat(qvSourceIPIsNot, "")
	if len(sourceIPIsNotIC) == 0 {
		return nil
	}

	var sourceIPIsNotIR []string
	for _, sourceIPIsNotIV := range sourceIPIsNotIC {
		sourceIPIsNotI := sourceIPIsNotIV

		sourceIPIsNotIR = append(sourceIPIsNotIR, sourceIPIsNotI)
	}

	o.SourceIPIsNot = sourceIPIsNotIR

	return nil
}

// bindSourceIPIs binds and validates array parameter SourceIPIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindSourceIPIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvSourceIPIs string
	if len(rawData) > 0 {
		qvSourceIPIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	sourceIPIsIC := swag.SplitByFormat(qvSourceIPIs, "")
	if len(sourceIPIsIC) == 0 {
		return nil
	}

	var sourceIPIsIR []string
	for _, sourceIPIsIV := range sourceIPIsIC {
		sourceIPIsI := sourceIPIsIV

		sourceIPIsIR = append(sourceIPIsIR, sourceIPIsI)
	}

	o.SourceIPIs = sourceIPIsIR

	return nil
}

// bindSpecDiffTypeIs binds and validates array parameter SpecDiffTypeIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindSpecDiffTypeIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvSpecDiffTypeIs string
	if len(rawData) > 0 {
		qvSpecDiffTypeIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	specDiffTypeIsIC := swag.SplitByFormat(qvSpecDiffTypeIs, "")
	if len(specDiffTypeIsIC) == 0 {
		return nil
	}

	var specDiffTypeIsIR []string
	for i, specDiffTypeIsIV := range specDiffTypeIsIC {
		specDiffTypeIsI := specDiffTypeIsIV

		if err := validate.EnumCase(fmt.Sprintf("%s.%v", "specDiffType[is]", i), "query", specDiffTypeIsI, []interface{}{"ZOMBIE_DIFF", "SHADOW_DIFF", "GENERAL_DIFF", "NO_DIFF"}, true); err != nil {
			return err
		}

		specDiffTypeIsIR = append(specDiffTypeIsIR, specDiffTypeIsI)
	}

	o.SpecDiffTypeIs = specDiffTypeIsIR

	return nil
}

// bindSpecContains binds and validates array parameter SpecContains from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindSpecContains(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvSpecContains string
	if len(rawData) > 0 {
		qvSpecContains = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	specContainsIC := swag.SplitByFormat(qvSpecContains, "")
	if len(specContainsIC) == 0 {
		return nil
	}

	var specContainsIR []string
	for _, specContainsIV := range specContainsIC {
		specContainsI := specContainsIV

		specContainsIR = append(specContainsIR, specContainsI)
	}

	o.SpecContains = specContainsIR

	return nil
}

// bindSpecEnd binds and validates parameter SpecEnd from query.
func (o *GetAPIUsageHitCountParams) bindSpecEnd(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.SpecEnd = &raw

	return nil
}

// bindSpecIsNot binds and validates array parameter SpecIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindSpecIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvSpecIsNot string
	if len(rawData) > 0 {
		qvSpecIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	specIsNotIC := swag.SplitByFormat(qvSpecIsNot, "")
	if len(specIsNotIC) == 0 {
		return nil
	}

	var specIsNotIR []string
	for _, specIsNotIV := range specIsNotIC {
		specIsNotI := specIsNotIV

		specIsNotIR = append(specIsNotIR, specIsNotI)
	}

	o.SpecIsNot = specIsNotIR

	return nil
}

// bindSpecIs binds and validates array parameter SpecIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindSpecIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvSpecIs string
	if len(rawData) > 0 {
		qvSpecIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	specIsIC := swag.SplitByFormat(qvSpecIs, "")
	if len(specIsIC) == 0 {
		return nil
	}

	var specIsIR []string
	for _, specIsIV := range specIsIC {
		specIsI := specIsIV

		specIsIR = append(specIsIR, specIsI)
	}

	o.SpecIs = specIsIR

	return nil
}

// bindSpecStart binds and validates parameter SpecStart from query.
func (o *GetAPIUsageHitCountParams) bindSpecStart(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.SpecStart = &raw

	return nil
}

// bindStartTime binds and validates parameter StartTime from query.
func (o *GetAPIUsageHitCountParams) bindStartTime(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("startTime", "query", rawData)
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// AllowEmptyValue: false

	if err := validate.RequiredString("startTime", "query", raw); err != nil {
		return err
	}

	// Format: date-time
	value, err := formats.Parse("date-time", raw)
	if err != nil {
		return errors.InvalidType("startTime", "query", "strfmt.DateTime", raw)
	}
	o.StartTime = *(value.(*strfmt.DateTime))

	if err := o.validateStartTime(formats); err != nil {
		return err
	}

	return nil
}

// validateStartTime carries on validations for parameter StartTime
func (o *GetAPIUsageHitCountParams) validateStartTime(formats strfmt.Registry) error {

	if err := validate.FormatOf("startTime", "query", "date-time", o.StartTime.String(), formats); err != nil {
		return err
	}
	return nil
}

// bindStatusCodeGte binds and validates parameter StatusCodeGte from query.
func (o *GetAPIUsageHitCountParams) bindStatusCodeGte(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.StatusCodeGte = &raw

	return nil
}

// bindStatusCodeIsNot binds and validates array parameter StatusCodeIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindStatusCodeIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvStatusCodeIsNot string
	if len(rawData) > 0 {
		qvStatusCodeIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	statusCodeIsNotIC := swag.SplitByFormat(qvStatusCodeIsNot, "")
	if len(statusCodeIsNotIC) == 0 {
		return nil
	}

	var statusCodeIsNotIR []string
	for _, statusCodeIsNotIV := range statusCodeIsNotIC {
		statusCodeIsNotI := statusCodeIsNotIV

		statusCodeIsNotIR = append(statusCodeIsNotIR, statusCodeIsNotI)
	}

	o.StatusCodeIsNot = statusCodeIsNotIR

	return nil
}

// bindStatusCodeIs binds and validates array parameter StatusCodeIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIUsageHitCountParams) bindStatusCodeIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvStatusCodeIs string
	if len(rawData) > 0 {
		qvStatusCodeIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	statusCodeIsIC := swag.SplitByFormat(qvStatusCodeIs, "")
	if len(statusCodeIsIC) == 0 {
		return nil
	}

	var statusCodeIsIR []string
	for _, statusCodeIsIV := range statusCodeIsIC {
		statusCodeIsI := statusCodeIsIV

		statusCodeIsIR = append(statusCodeIsIR, statusCodeIsI)
	}

	o.StatusCodeIs = statusCodeIsIR

	return nil
}

// bindStatusCodeLte binds and validates parameter StatusCodeLte from query.
func (o *GetAPIUsageHitCountParams) bindStatusCodeLte(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.StatusCodeLte = &raw

	return nil
}
